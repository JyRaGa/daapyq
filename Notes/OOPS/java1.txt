
# **THE ULTIMATE LEARNING GUIDE: JAVA (PART 1)**
*(Covers Units 3 & 4 of your Question Bank)*

## **UNIT 3: Java Basics & OOP Concepts**

### **Topic 1: The Java Environment (Why Java?)**

**Q1. "JVM is critical for Java programs." Justify.**
*   **The Problem:** C++ compiles to "Machine Code" (0s and 1s) specific to one OS (e.g., Windows). It won't run on Mac or Linux without recompiling.
*   **The Java Solution:** Java compiles to **Bytecode** (`.class`), which is a universal language.
*   **The JVM's Role:** The **Java Virtual Machine (JVM)** acts as a translator.
    *   It takes the Universal Bytecode.
    *   It translates it *on the fly* to the specific Machine Code of the computer it is running on.
*   **Conclusion:** Without JVM, there is no "Platform Independence". It is the engine that makes "Write Once, Run Anywhere" possible.

**Q2. JRE vs JDK vs JVM (The Hierarchy).**
*   **JVM (Java Virtual Machine):** The abstract machine that executes bytecode. It exists in RAM.
*   **JRE (Java Runtime Environment):** **JVM + Libraries**. This is what a *user* needs to run games or apps. They don't need compilers.
*   **JDK (Java Development Kit):** **JRE + Development Tools**. This contains the Compiler (`javac`), Debugger, and JRE. This is what *programmers* need.

**Q3. Strictly Java-Based Features (Not in C++).**
1.  **Automatic Garbage Collection:** You create objects (`new`), but you never delete them. A background process (Garbage Collector) automatically frees memory when objects are no longer used.
2.  **Platform Independence:** C++ is platform-dependent; Java is not.
3.  **No Pointers:** Java removed pointer arithmetic (`ptr++`) to prevent memory corruption and hacking vulnerabilities.

**Q4. The "Bytecode" Concept.**
*   **Definition:** Highly optimized set of instructions generated by the Java Compiler (`javac`).
*   **Why "Bytecode"?** Each instruction is exactly 1 byte long opcode.
*   **Nature:** It is not readable by humans, and not runnable by hardware. Only the JVM understands it.

***

### **Topic 2: Java OOPs (Classes, Interfaces, Packages)**

**Q5. Java Access Specifiers (The 4 Levels).**
*   **Private:** Visible ONLY inside the class.
*   **Default (No keyword):** Visible inside the **same package** only.
*   **Protected:** Visible in same package + **Subclasses** (even in other packages).
*   **Public:** Visible everywhere.

**Q6. Abstract Class vs Interface.**
*   **Abstract Class:**
    *   Can have variables with values.
    *   Can have constructors.
    *   Can have normal methods (with body).
    *   **Limitation:** A class can extend only ONE abstract class.
*   **Interface:**
    *   Variables are implicitly `public static final` (Constants only).
    *   No constructors.
    *   Methods are implicitly `public abstract` (No body).
    *   **Power:** A class can implement **multiple** interfaces.

**Q7. Implementing Multiple Inheritance (The Interface Trick).**
*   **Question:** *"How does Java support multiple inheritance? Explain with code."*
*   **The Logic:** Java bans `class C extends A, B`. But it allows `class C implements A, B`.
*   **Code:**
    ```java
    interface Printer { void print(); }
    interface Scanner { void scan(); }

    // This class is now both a Printer and a Scanner
    class AllInOne implements Printer, Scanner {
        public void print() { System.out.println("Printing..."); }
        public void scan() { System.out.println("Scanning..."); }
    }
    ```

**Q8. Packages (Organizing Code).**
*   **What is it?** A folder that groups related classes. It prevents name conflicts (e.g., `java.sql.Date` vs `java.util.Date`).
*   **How to create:** Put `package mypack;` at the top of your file.
*   **How to use:** `import mypack.MyClass;`

***

### **Topic 3: Vectors & Wrappers**

**Q9. Vector vs ArrayList.**
*   **Vector:** Old (Legacy). Synchronized (Thread-safe). Slow. Increases size by 100% when full.
*   **ArrayList:** New (Collections Framework). Not Synchronized. Fast. Increases size by 50% when full.
*   **Verdict:** Almost always use `ArrayList`.

**Q10. Wrapper Classes & Type Casting.**
*   **Primitive:** `int`, `float`, `char` (Fast, but not Objects).
*   **Wrapper:** `Integer`, `Float`, `Character` (Objects, slower).
*   **Auto-Boxing:** Automatic conversion (`int` -> `Integer`). `Integer obj = 10;`
*   **Un-Boxing:** Automatic conversion (`Integer` -> `int`). `int x = obj;`

***

## **UNIT 4: Java Advanced Features**

### **Topic 4: Exception Handling (Managing Errors)**

**Q11. Checked vs Unchecked Exceptions.**
*   **Checked (Compile-Time):** The compiler forces you to handle these. Usually external problems.
    *   *Examples:* `IOException` (File not found), `SQLException`.
*   **Unchecked (Run-Time):** The compiler ignores these. They are usually programming errors.
    *   *Examples:* `NullPointerException` (Accessing null), `ArithmeticException` (Divide by 0).

**Q12. The Keywords: `throw` vs `throws`.**
*   **`throw`:** An **action**. You are actively throwing an exception right now.
    *   `if(age < 18) throw new Exception("Too young");`
*   **`throws`:** A **warning**. You declare it in the function header to tell the caller "This might happen".
    *   `void checkAge() throws Exception { ... }`

**Q13. The `finally` Block.**
*   **Concept:** A block of code that runs **no matter what**.
    *   If exception occurs -> `catch` runs -> then `finally` runs.
    *   If no exception -> `try` runs -> then `finally` runs.
    *   Even if you `return` inside try, `finally` runs first!
*   **Use Case:** Closing files, closing database connections.

**Q14. Rethrowing Exceptions.**
*   **Logic:** You catch an error, log it, but realize you can't fix it. So you throw it again to the main function.
*   **Code:**
    ```java
    try {
        // risky code
    } catch(Exception e) {
        System.out.println("Logging error...");
        throw e; // Pass the hot potato!
    }
    ```

***

### **Topic 5: Multithreading (Doing 2 things at once)**

**Q15. Thread Lifecycle (The 5 States).**
1.  **New:** Thread object created (`new Thread()`), but not started.
2.  **Runnable:** `start()` is called. It's ready, waiting for the CPU.
3.  **Running:** The CPU is actually executing it.
4.  **Blocked/Waiting:** It paused itself (`sleep()`, `wait()`) or is waiting for I/O.
5.  **Terminated:** The `run()` method finished. The thread is dead.

**Q16. Creating Threads (2 Ways).**
*   **Method 1: Extend `Thread` Class.**
    *   `class Worker extends Thread { public void run() { ... } }`
    *   `new Worker().start();`
*   **Method 2: Implement `Runnable` Interface (Better).**
    *   `class Job implements Runnable { public void run() { ... } }`
    *   `new Thread(new Job()).start();`
    *   *Why better?* Because your class can still extend another class (Java only allows extending one class).

**Q17. Synchronization (Preventing Chaos).**
*   **Problem:** Two threads try to update the same variable (e.g., Bank Balance) at the exact same time. Data gets corrupted.
*   **Solution:** Use the `synchronized` keyword.
    *   `synchronized void deposit(int amt) { balance += amt; }`
    *   This creates a "lock". Only one thread can enter this function at a time. Others must wait in line.

***

### **SECTION 6: Extra Unit 3 – Java Fundamentals & OOP**

**1. Purpose of common library methods.**

- `toString()`  
  Defined in class `Object`, overridden by most classes. Returns a **string representation** of the object, used automatically by `System.out.println(obj)`.  
  Example: in a `Student` class, override it to print roll and name.

- `nextDouble()` (in `Scanner`)  
  Reads the **next token** of input and converts it to a `double`. Throws `InputMismatchException` if the token is not a valid double.

- `System.out.println()`  
  Prints a value (using `toString()` for objects), then adds a newline. Overloaded to handle all primitive types and `Object`.

- `public static void main(String args[])`  
  Entry point for Java application.  
  - `public`: callable by JVM.  
  - `static`: does not require an object.  
  - `void`: returns no value.  
  - `String args[]`: command‑line arguments.

***

**2. Detailed access specifier privileges (with examples).**

Access from: **same class**, **same package**, **subclass in another package**, **unrelated class in another package**.

| Modifier   | Same class | Same package | Subclass (other pkg) | Other pkg non‑subclass |
|------------|-----------|--------------|-----------------------|------------------------|
| `private`  | Yes       | No           | No                    | No                     |
| (default)  | Yes       | Yes          | No                    | No                     |
| `protected`| Yes       | Yes          | Yes                   | No                     |
| `public`   | Yes       | Yes          | Yes                   | Yes                    |

Example:

```java
package p1;
public class A {
    private   int pri;
              int def;      // default
    protected int pro;
    public    int pub;
}
```

In `p1.B` (same package): can access `def`, `pro`, `pub`; not `pri`. In `p2.C extends A` (different package): can access `pro`, `pub` via inheritance; not `def` or `pri`. In `p2.D` (unrelated): can only access `pub`.

***

**3. Detailed packages: creation, hierarchy, classpath.**

- **Creating a package:**

```java
// File: mypack/Hello.java
package mypack;

public class Hello {
    public void greet() {
        System.out.println("Hello from mypack");
    }
}
```

Compile with:

```bash
javac -d . Hello.java
```

`-d .` tells `javac` to create the folder structure `mypack/`.

- **Using a package:**

```java
import mypack.Hello;
class Test {
    public static void main(String[] args) {
        Hello h = new Hello();
        h.greet();
    }
}
```

- **Package hierarchy and classpath:**  
  If you have `package com.dtu.oop;`, the folder hierarchy must be `com/dtu/oop/Hello.class`. The **classpath** is a list of root folders/jars where the JVM & compiler search for packages.

***

**4. Interfaces – `cricket_team` example.**

```java
interface CricketTeam {
    void selectPlayers();
    void playMatch();
}

class IndiaTeam implements CricketTeam {
    public void selectPlayers() {
        System.out.println("Selecting 11 players for India");
    }
    public void playMatch() {
        System.out.println("India is playing a match");
    }
}
```

A class can implement **multiple** interfaces, e.g., `CricketTeam`, `Sponsorship`, etc.

***

**5. Abstract classes vs interfaces – detailed example.**

```java
abstract class Shape {
    String color;
    Shape(String c) { color = c; }
    abstract double area();     // must be implemented by subclasses
    void showColor() { System.out.println(color); }
}

interface Drawable {
    void draw();
}

class Circle extends Shape implements Drawable {
    double r;
    Circle(double r, String c) {
        super(c);
        this.r = r;
    }
    double area() { return Math.PI * r * r; }
    public void draw() { System.out.println("Drawing circle"); }
}
```

- Use **abstract class** when you have **some common implementation + some abstract behavior**.
- Use **interface** to define a **pure contract** to be implemented by many unrelated classes.

***

**6. Function overriding with `@Override`, `super`, polymorphism.**

```java
class Animal {
    void sound() { System.out.println("Animal sound"); }
}

class Dog extends Animal {
    @Override
    void sound() {
        super.sound(); // call base version
        System.out.println("Dog barks");
    }
}

public class Demo {
    public static void main(String[] args) {
        Animal a = new Dog(); // upcasting
        a.sound();            // runtime polymorphism → Dog.sound()
    }
}
```

***

**7. Simple `Student` class.**

```java
class Student {
    int roll;
    String name;

    void accept(int r, String n) {
        roll = r; name = n;
    }
    void display() {
        System.out.println("Roll: " + roll + " Name: " + name);
    }
}
```

***

**8. Type conversion and casting.**

- **Primitive casting:**

```java
int i = 10;
double d = i;         // widening (automatic)
int j = (int) 3.7;    // narrowing (cast required)
```

- **Wrapper & autoboxing:**

```java
Integer obj = 10;    // int → Integer (autobox)
int x = obj;         // Integer → int (unbox)
```

- **Upcasting and downcasting with objects:**

```java
Animal a = new Dog();       // upcast (implicit)
Dog d2 = (Dog) a;           // downcast (explicit)
```

***

**9. Example programs – Math, String, Vector, ArrayList.**

```java
// Math & String
double p = Math.pow(2, 3);        // 8.0
double r = Math.sqrt(25);         // 5.0
String s = "Hello";
String t = s.substring(1, 4);     // "ell"
String u = s.concat(" World");    // "Hello World"
int len = s.length();             // 5
```

```java
// Vector and ArrayList
import java.util.*;

Vector<String> v = new Vector<>();
v.add("A");
v.add("B");
v.remove("A");
for (String e : v) System.out.println(e);

ArrayList<Integer> al = new ArrayList<>();
al.add(10);
al.add(20);
System.out.println(al.get(1));    // 20
System.out.println(al.size());    // 2
```

***

**10. Vector CRUD (insert, update, iterate, delete).**

```java
import java.util.*;

public class VectorDemo {
    public static void main(String[] args) {
        Vector<String> v = new Vector<>();

        // Insert
        v.add("One");
        v.add("Two");
        v.add("Three");

        // Update
        v.set(1, "TWO"); // index 1

        // Iterate
        for (String s : v) {
            System.out.println(s);
        }

        // Delete
        v.remove("One");
        v.remove(0); // remove by index
    }
}
```

***

### **SECTION 7: Extra Unit 4 – Exceptions & Multithreading**

**11. Error vs Exception (Java).**

- **Error** (`java.lang.Error`): Serious problems usually not handled by applications (e.g., `OutOfMemoryError`, `StackOverflowError`).  
- **Exception** (`java.lang.Exception`): Conditions that applications are expected to catch and handle (e.g., `IOException`, `NumberFormatException`).

***

**12. Checked vs unchecked exceptions – detailed.**

- **Checked** (must be declared or caught):
  - `IOException`, `SQLException`.
  - The compiler enforces `try-catch` or `throws`.

```java
void readFile() throws IOException {
    FileReader fr = new FileReader("a.txt");
}
```

- **Unchecked** (runtime):
  - `NullPointerException`, `ArithmeticException`, `ArrayIndexOutOfBoundsException`.
  - No compile-time checking.

```java
int a = 10 / 0;             // ArithmeticException
String s = null;
s.length();                 // NullPointerException
```

***

**13. `throw` vs `throws` – full example.**

```java
class AgeInvalidException extends Exception {
    AgeInvalidException(String msg) { super(msg); }
}

class Voter {
    static void check(int age) throws AgeInvalidException {
        if (age < 18)
            throw new AgeInvalidException("Too young");
    }
}
```

- `throw` creates and **throws** an exception instance.
- `throws` declares that a method **might throw** that exception and passes responsibility to the caller.

***

**14. Nested try-catch with custom exception and finally.**

```java
class CustomEx extends Exception {
    CustomEx(String msg) { super(msg); }
}

public class NestedDemo {
    public static void risky() throws CustomEx {
        try {
            int a = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Inner caught: " + e);
            throw new CustomEx("Wrapped exception");
        }
    }

    public static void main(String[] args) {
        try {
            risky();
        } catch (CustomEx e) {
            System.out.println("Outer caught: " + e.getMessage());
        } finally {
            System.out.println("Finally always runs");
        }
    }
}
```

***

**15. Multithreading example – two threads (1–10 and A–J) with sync & priorities.**

```java
class Printer {
    synchronized void printNumbers() {
        for (int i = 1; i <= 10; i++) {
            System.out.print(i + " ");
        }
        System.out.println();
    }
    synchronized void printLetters() {
        for (char c = 'A'; c <= 'J'; c++) {
            System.out.print(c + " ");
        }
        System.out.println();
    }
}

class NumThread extends Thread {
    Printer p;
    NumThread(Printer p) { this.p = p; }
    public void run() { p.printNumbers(); }
}

class CharThread extends Thread {
    Printer p;
    CharThread(Printer p) { this.p = p; }
    public void run() { p.printLetters(); }
}

public class MTMain {
    public static void main(String[] args) {
        Printer p = new Printer();
        NumThread t1 = new NumThread(p);
        CharThread t2 = new CharThread(p);

        t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);

        t1.start();
        t2.start();
    }
}
```

This demonstrates:

- Two threads sharing a resource (`Printer`).
- `synchronized` to ensure one thread enters `printNumbers` or `printLetters` at a time.
- Use of priorities (`MAX_PRIORITY`, `MIN_PRIORITY`).

***
